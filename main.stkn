jQuery(document).ready(%)

canvas: document.getElementById('canvas')
display: document.getElementById('display')

func randomColor()
    letters: '0123456789ABCDEF'.split('')
    return '#c' + letters[Math.round(Math.random() * 15)] +
           'f' + letters[Math.round(Math.random() * 15)] +
           'b' + letters[Math.round(Math.random() * 15)]

func fade(node, opacity, rate, cb)
    if opacity <= 0
        node.style.opacity: 0
        return cb()
    node.style.backgroundColor: randomColor()
    node.style.opacity: opacity
    setTimeout(%, 20)
    fade(node, opacity - rate, rate, cb)

func aaHeight()
    return jQuery('#rb_anchor')[0].offsetTop -
           jQuery('#lt_anchor')[0].offsetTop

func aaWidth()
    return jQuery('#rb_anchor')[0].offsetLeft -
           jQuery('#lt_anchor')[0].offsetLeft

func createFloatingPiece()
    parent: document.createElement('div')
    jQuery(parent).addClass('parent')
    div: document.createElement('div')
    div.style.position: 'relative'
    parent.appendChild(div)
    canvas.appendChild(parent)
    div.remove: (): jQuery(parent).remove()
    return div

###########
# OPENING #
###########

TILE_SIZE: 8

height: Math.ceil(aaHeight() / TILE_SIZE) + 1 # +1 for underscore at the last line
width: Math.ceil(aaWidth() / TILE_SIZE) + 1

covers: []
func cover(x, y)
    if y = height
        return

    div: createFloatingPiece()
    div.style.backgroundColor: '#c8f0b8'
    div.style.height: TILE_SIZE + 'px'
    div.style.width: TILE_SIZE + 'px'
    div.style.top: TILE_SIZE * y + 'px'
    div.style.left: TILE_SIZE * x + 'px'
    covers.push(div)

    if x + 1 = width
        cover(0, y + 1)
    else
        cover(x + 1, y)
cover(0, 0)

DIRECTIONS: {
    right: {
        delta: [1, 0],
        step: (status): status.width,
        split: (status):
            next_direct: 'down'
            if status.height = 1
                return []
            if status.width = 1
                return [{
                    width: 1,
                    height: status.height - 1,
                    x: status.x,
                    y: status.y + 1,
                    direct: next_direct,
                }]
            widthA: Math.floor(status.width / 2)
            widthB: status.width - widthA
            return [{
                width: widthA,
                height: status.height - 1,
                x: status.x + widthA - 1,
                y: status.y + 1,
                direct: next_direct,
            }, {
                width: widthB,
                height: status.height - 1,
                x: status.x + status.width - 1,
                y: status.y + 1,
                direct: next_direct,
            }]
    },
    down: {
        delta: [0, 1],
        step: (status): status.height,
        split: (status):
            next_direct: 'left'
            if status.width = 1
                return []
            if status.height = 1
                return [{
                    width: status.width - 1,
                    height: 1,
                    x: status.x - 1,
                    y: status.y,
                    direct: next_direct,
                }]
            heightA: Math.floor(status.height / 2)
            heightB: status.height - heightA
            return [{
                width: status.width - 1,
                height: heightA,
                x: status.x - 1,
                y: status.y + heightA - 1,
                direct: next_direct,
            }, {
                width: status.width - 1,
                height: heightB,
                x: status.x - 1,
                y: status.y + status.height - 1,
                direct: next_direct,
            }]
    },
    left: {
        delta: [-1, 0],
        step: (status): status.width,
        split: (status):
            next_direct: 'up'
            if status.height = 1
                return []
            if status.width = 1
                return [{
                    width: 1,
                    height: status.height - 1,
                    x: status.x,
                    y: status.y - 1,
                    direct: next_direct
                }]
            widthA: Math.floor(status.width / 2)
            widthB: status.width - widthA
            return [{
                width: widthA,
                height: status.height - 1,
                x: status.x - widthA + 1,
                y: status.y - 1,
                direct: next_direct,
            }, {
                width: widthB,
                height: status.height - 1,
                x: status.x - status.width + 1,
                y: status.y - 1,
                direct: next_direct,
            }]
    },
    up: {
        delta: [0, -1],
        step: (status): status.height,
        split: (status):
            next_direct: 'right'
            if status.width = 1
                return []
            if status.height = 1
                return [{
                    width: status.width - 1,
                    height: 1,
                    x: status.x + 1,
                    y: status.y,
                    direct: next_direct,
                }]
            heightA: Math.floor(status.height / 2)
            heightB: status.height - heightA
            return [{
                width: status.width - 1,
                height: heightA,
                x: status.x + 1,
                y: status.y - heightA + 1,
                direct: next_direct,
            }, {
                width: status.width - 1,
                height: heightB,
                x: status.x + 1,
                y: status.y - status.height + 1,
                direct: next_direct,
            }]
    },
}

func start(status, act)
    func turn(status)
        direction: DIRECTIONS[status.direct]
        direction.split(status) |:
            nextStep($, DIRECTIONS[$.direct].step($), $.x, $.y)

    func nextStep(status, step, x, y)
        if step = 0
            return turn(status)
        setTimeout(%, 25)
        act(x, y)
        nextStep(status, step - 1, x + DIRECTIONS[status.direct].delta[0],
                 y + DIRECTIONS[status.direct].delta[1])

    if status.height = 0 || status.width = 0
        return
    nextStep(status, DIRECTIONS[status.direct].step(status), status.x,
             status.y)

func removeTile(x, y)
    tile: covers[y * width + x]
    fade(tile, .8, .05, (): tile.remove())

halfW: Math.floor(width / 2)

start({
    width: halfW,
    height: height,
    x: 0,
    y: height - 1,
    direct: 'up',
}, removeTile)
start({
    width: width - halfW,
    height: height,
    x: width - 1,
    y: 0,
    direct: 'down',
}, removeTile)

############
# HOVERING #
############

func createFences(leftoff, upoff, width, height)
    total: width + height
    length: Math.floor(width * 2 / 3)

    top: createFloatingPiece()
    top.style.visibility: 'hidden'
    top.style.backgroundColor: '#c8f0b8'
    top.style.top: upoff + 'px'
    top.style.height: '1px'
    bottom: createFloatingPiece()
    bottom.style.visibility: 'hidden'
    bottom.style.backgroundColor: '#c8f0b8'
    bottom.style.top: (upoff + height) + 'px'
    bottom.style.height: '1px'

    right: createFloatingPiece()
    right.style.visibility: 'hidden'
    right.style.backgroundColor: '#c8f0b8'
    right.style.left: (leftoff + width) + 'px'
    right.style.width: '1px'
    left: createFloatingPiece()
    left.style.visibility: 'hidden'
    left.style.backgroundColor: '#c8f0b8'
    left.style.left: leftoff + 'px'
    left.style.width: '1px'

    topCand: createFloatingPiece()
    topCand.style.visibility: 'hidden'
    topCand.style.backgroundColor: '#c8f0b8'
    topCand.style.top: upoff + 'px'
    topCand.style.left: leftoff + 'px'
    topCand.style.height: '1px'

    bottomCand: createFloatingPiece()
    bottomCand.style.visibility: 'hidden'
    bottomCand.style.backgroundColor: '#c8f0b8'
    bottomCand.style.top: (upoff + height) + 'px'
    bottomCand.style.height: '1px'

    return {
        tick: 0,
        remove: ():
            top.remove()
            bottom.remove()
            right.remove()
            left.remove()
            topCand.remove()
            bottomCand.remove()
        ,
        nextTick: ():
            if 0 <= @tick && @tick <= width - length
                top.style.width: length + 'px'
                top.style.left: (leftoff + @tick) + 'px'
                bottom.style.width: length + 'px'
                bottom.style.left: (leftoff + width - length - @tick) + 'px'

                top.style.visibility: 'visible'
                bottom.style.visibility: 'visible'
                topCand.style.visibility: 'hidden'
                bottomCand.style.visibility: 'hidden'
            if width - length < @tick && @tick < width
                top.style.width: (width - @tick) + 'px'
                top.style.left: (leftoff + @tick) + 'px'
                bottom.style.width: (width - @tick) + 'px'
                bottom.style.left: leftoff + 'px'

                top.style.visibility: 'visible'
                bottom.style.visibility: 'visible'
            if @tick = width
                top.style.visibility: 'hidden'
                bottom.style.visibility: 'hidden'

            sideLen: length - (width - @tick)
            if width - length < @tick && @tick <= width
                right.style.top: upoff + 'px'
                if sideLen < height
                    right.style.height: sideLen + 'px'
                    left.style.height: sideLen + 'px'
                    left.style.top: (upoff + total - length - @tick) + 'px'
                else
                    right.style.height: height + 'px'
                    left.style.height: height + 'px'
                    left.style.top: upoff + 'px'

                right.style.visibility: 'visible'
                left.style.visibility: 'visible'
            if width < @tick && @tick <= total - length
                left.style.top: (upoff + total - length - @tick) + 'px'
                if length < height
                    right.style.height: length + 'px'
                    right.style.top: (upoff + @tick - width) + 'px'
                    left.style.height: length + 'px'
                else
                    right.style.height: height + 'px'
                    right.style.top: upoff + 'px'
                    left.style.height: height + 'px'

                right.style.visibility: 'visible'
                left.style.visibility: 'visible'
            sideRest: total - @tick
            if total - length < @tick && @tick < total
                left.style.top: upoff + 'px'
                if sideRest < height
                    right.style.height: sideRest + 'px'
                    left.style.height: sideRest + 'px'
                    right.style.top: (upoff + @tick - width) + 'px'
                else
                    right.style.height: height + 'px'
                    left.style.height: height + 'px'
                    right.style.top: upoff + 'px'

                right.style.visibility: 'visible'
                left.style.visibility: 'visible'

            if @tick = 0
                right.style.visibility: 'hidden'
                left.style.visibility: 'hidden'

            candLen: @tick + length - total
            if total < @tick + length
                topCand.style.width: candLen + 'px'
                bottomCand.style.width: candLen + 'px'
                bottomCand.style.left: (leftoff + width - candLen) + 'px'

                topCand.style.visibility: 'visible'
                bottomCand.style.visibility: 'visible'

            @tick: (@tick + 1) % total
    }

jQuery('.label').each(():
    @tick: 0
).hover(():
    @fences: createFences(@offsetLeft - 4, @offsetTop - 2, @offsetWidth + 8,
                          @offsetHeight + 4)
    @fences.tick: @tick
    fences: @fences
    @nextTick: setInterval((): fences.nextTick(), 20)
, ():
    @tick: @fences.tick
    @fences.remove()
    clearTimeout(@nextTick)
)

#######
# EGG #
#######

jQuery('#n').click(():
    target: document.getElementById('nx')
    me: @
    if @fences
        clearTimeout(@nextTick)
        @fences.remove()
        @fences: null
        target.style.visibility: 'visible'
        document.getElementById('ny').style.visibility: 'visible'
    else
        @fences: createFences(target.offsetLeft, target.offsetTop,
                              target.offsetWidth, target.offsetHeight)
        @nextTick: setInterval((): me.fences.nextTick(), 20)
        target.style.visibility: 'hidden'
        document.getElementById('ny').style.visibility: 'hidden'
)
